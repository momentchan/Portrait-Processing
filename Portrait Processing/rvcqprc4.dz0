#include <opencv2/objdetect/objdetect.hpp>
#include <opencv2/objdetect/objdetect_c.h>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/highgui/highgui_c.h>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/imgproc/types_c.h>
#include <iostream>
#include <stdlib.h>
#include <stdio.h>
using namespace std;
using namespace cv;

/** Function Headers */
void FaceDetection();
void ContourExtraction();
void CannyThreshold(int, void*);
float MWCalculation(Moments, Point2f);
int HistogramCalulation(Mat image);
void Binarization();
void Refinement();
void RefineThreshold(int, void*);
void Separation();
void DrawSimulation();
void SketchSimulation();
void FillSimulation();
bool CompareLength(vector<Point> contour1, vector<Point> contour2);
void FindBlobs(const Mat &binary, vector < vector<Point2i> > &blobs, Mat &label_image);
void ConnectedComponent();
Rect BoundingBox(Mat);
Mat HoleFilling(Mat);

//Variables for face detection
bool detect_face = false;
Mat capture_frame;
Mat grayscale_frame;
Mat R1;
Mat R2;
float w;
float h;
Point2f center;

//Variables for contour extraction
Mat a2_edges, detect_edges;
int low_threshold=60;
int const max_threshold = 100;
int ratio = 2;
int kernel_size = 3;
float Ts = 0.1;
Mat a4_edges;

//Variables for image binarization
Mat b2_binary;
float alpha = 0.23;

//Variables for image refinement
Mat b3_refine;
int morph_elem = 0; //Rec
int morph_size = 2;
int const max_morph_size = 10;
int const open_operator = 2;
int const close_operator = 3;
char* refine_window = "Image Refinement";
RNG rng(12345);

//Variables for image refinement
Mat b4_area;
Mat portrait;

//Variablse for image separation
Mat b3_invert;

//Variables for showing images
bool contourShow = 0;
bool binaryShow = 0;
bool refineShow = 0;
bool separateShow = 0;

//Variables for drawing simulation
vector<vector<Point> > contours_filtered;
Mat simulation;
//Mat holefilled;
vector<Rect> boundRects;
vector < vector<Point2i > > blobs;
Mat label_image;


int main(int argc, const char** argv)
{
	//Tracking and detecting face
	//FaceDetection();	
	
	R1 = imread("R1.jpg", CV_BGR2GRAY);
	R2 = imread("R2.jpg", CV_BGR2GRAY);
	w = R2.size().width;
	h = R2.size().height;
	center = Point(w / 2, h / 2);

	//Extracting contour of portrait for trajectory computation
	ContourExtraction();
	
	//Image Binarization
	Binarization();

	//b2_binary = imread("b2_binary.jpg", CV_BGR2GRAY);
	//Image Refinement
	Refinement();

	//Image Separation
	//b3_refine = imread("b3_refine_c1o2.jpg", CV_BGR2GRAY);
	//a4_edges = imread("a4_edges.jpg", CV_BGR2GRAY);
	Separation();

	//Draw Simulation
	DrawSimulation();
}

void FaceDetection(){
	//create the cascade classifier object used for the face detection
	CascadeClassifier face_cascade;
	//use the haarcascade_frontalface_alt.xml library
	face_cascade.load("haarcascade_frontalface_alt.xml");

	//setup video capture device and link it to the first capture device
	VideoCapture captureDevice;
	captureDevice.open(0);

	//create a window to present the results
	namedWindow("Face Detecting...", CV_WINDOW_AUTOSIZE);

	//create a loop to capture and find faces
	Mat R1_color, R2_color;
	while (!detect_face)
	{
		//capture a new image frame
		captureDevice >> capture_frame;

		//convert captured image to gray scale and equalize
		cvtColor(capture_frame, grayscale_frame, CV_BGR2GRAY);
		equalizeHist(grayscale_frame, grayscale_frame);

		//create a vector array to store the face found
		vector<Rect> faces;

		//find faces and store them in the vector array
		face_cascade.detectMultiScale(grayscale_frame, faces, 1.1, 3, CV_HAAR_FIND_BIGGEST_OBJECT | CV_HAAR_SCALE_IMAGE, Size(30, 30));

		//draw a rectangle for all found faces in the vector array on the original image
		for (int i = 0; i < faces.size(); i++)
		{
			int width = faces[i].width;
			int height = faces[i].height;
			int x = faces[i].x;
			int y = faces[i].y;

			Point pt1(x + width, y + height);
			Point pt2(x, y);

			R1 = grayscale_frame(Rect(x, y, width, height));
			R1_color = capture_frame(Rect(x, y, width, height));

			if (x - round(round(width / 2)) > 0 && y - round(height / 4) > 0 &&
				x - round(width / 2) + width * 2 < 640 && y - round(height / 4) + height * 2 < 480){
				R2 = grayscale_frame(Rect(x - round(width / 2), y - round(height / 4), width * 2, height * 2));
				R2_color = capture_frame(Rect(x - round(width / 2), y - round(height / 4), width * 2, height * 2));
				detect_face = true;
			}

			//Draw rectangle
			rectangle(capture_frame, pt1, pt2, cvScalar(0, 255, 0, 0), 1, 8, 0);
		}
		//print the output
		imshow("Face Detecting...", capture_frame);
		cvWaitKey(33);
	}
	destroyWindow("Face Detecting...");

	resize(R1, R1, Size(200, 200));
	resize(R1_color, R1_color, Size(200, 200));
	resize(R2, R2, Size(400, 400));
	resize(R2_color, R2_color, Size(400, 400));
	//Create a window to present the detecting results
	namedWindow("Face Region", CV_WINDOW_AUTOSIZE);
	imshow("Face Region", R1_color);
	namedWindow("Portrait Region", CV_WINDOW_AUTOSIZE);
	imshow("Portrait Region", R2_color);
	imwrite("R1.jpg", R1);
	imwrite("R2.jpg", R2);
	imwrite("R1_color.jpg", R1_color);
	imwrite("R2_color.jpg", R2_color);
	cvWaitKey(0);
}
void ContourExtraction(){
	cout << "Extraction contour..." << endl;
	a2_edges.create(R2.size(), R2.type());
	if (contourShow){
		/// Create a window
		namedWindow("Original Edges", CV_WINDOW_AUTOSIZE);
		/// Create a Trackbar for user to enter threshold
		createTrackbar("Min Threshold:", "Original Edges", &low_threshold, max_threshold, CannyThreshold);
	}
	/// Show the image
	CannyThreshold(0, 0);
	cvWaitKey(0);
}
void CannyThreshold(int, void*){
	/// Reduce noise with a kernel 3x3
	blur(R2, detect_edges, Size(3, 3));

	vector<vector<Point> > contours;
	vector<Vec4i> hierarchy;

	/// Detect edges using canny
	Canny(detect_edges, detect_edges, low_threshold, low_threshold*ratio, kernel_size);

	/// Find contours
	findContours(detect_edges, contours, hierarchy, CV_RETR_TREE, CV_CHAIN_APPROX_TC89_L1, Point(0, 0));
	
	/// Get the moments
	vector<Moments> mu(contours.size());
	for (int i = 0; i < contours.size(); i++)
		mu[i] = moments(contours[i], false);

	///  Get the mass centers:
	contours_filtered.clear();
	vector<Point2f> mc(contours.size());
	vector<float> MomentWeights(contours.size());
	for (int i = 0; i < contours.size(); i++) {
		mc[i] = Point2f(mu[i].m10 / mu[i].m00, mu[i].m01 / mu[i].m00);
		MomentWeights[i] = MWCalculation(mu[i], mc[i]);
		if (MomentWeights[i]> Ts)
			contours_filtered.push_back(contours[i]);
	}

	/// Draw contours
	Mat edge_origin = Mat::ones(detect_edges.size(), CV_8UC3);
	Mat edge_filtered = Mat::ones(detect_edges.size(), CV_8UC3);
	a4_edges = Mat::ones(detect_edges.size(), CV_8UC1);
	edge_origin.setTo(Scalar(255, 255, 255));
	edge_filtered.setTo(Scalar(255, 255, 255));
	a4_edges.setTo(Scalar(255, 255, 255));

	for (int i = 0; i< contours.size(); i++) {
		Scalar color = Scalar(rng.uniform(0, 255), rng.uniform(0, 255), rng.uniform(0, 255));
		drawContours(edge_origin, contours, i, color, 1, 8, hierarchy, 2, Point());
		if (MomentWeights[i]> Ts){
			//cout << mc[i]-Point2f(200,200)<<"  "<<mu[i].m00<<"  "<<MomentWeights[i] << endl;
			//Color
			drawContours(edge_filtered, contours, i, color, 1, 8, hierarchy, 2, Point());
			//Black
			drawContours(a4_edges, contours, i, Scalar(0, 0, 0), 1, 8, hierarchy, 2, Point());
		}
	}
	cout << "Number of Edges before filtering : " << contours.size() << endl;
	cout << "Number of Edges after filtering : " << contours_filtered.size() << endl<<endl;
	// Morphological filtering
	Mat element = getStructuringElement(morph_elem, Size(2 * 1 + 1, 2 * 1 + 1), Point(morph_size, morph_size));
	erode(a4_edges, a4_edges, element);

	/// Show in a window
	imwrite("a2_edge_origin.jpg", edge_origin);
	imwrite("a3_edge_filtered.jpg", edge_filtered);
	imwrite("a4_edges.jpg", a4_edges);
	if (contourShow){
		imshow("Original Edges", edge_origin);
		imshow("Filtered Edges", edge_filtered);
		imshow("Final Edges", a4_edges);
	}
}
float MWCalculation(Moments mu, Point2f mc){
	return mu.m00 / norm(Mat(mc), Mat(center));
}
int HistogramCalulation(Mat image){
	// allcoate memory for no of pixels for each intensity value
	int histogram[256];

	// initialize all intensity values to 0
	for (int i = 0; i < 255; i++)
		histogram[i] = 0;

	// calculate the no of pixels for each intensity values
	for (int y = 0; y < image.rows; y++)
	for (int x = 0; x < image.cols; x++)
		histogram[(int)image.at<uchar>(y, x)]++;

	// draw the histograms
	int hist_w = 512; int hist_h = 400;
	int bin_w = cvRound((double)hist_w / 256);

	Mat histImage(hist_h, hist_w, CV_8UC1, Scalar(255, 255, 255));

	// find the maximum intensity element from histogram
	int max_num = histogram[0];
	int max = 0;
	int total_num = image.size().area();
	int threshold = total_num*alpha;
	int accumulate = 0;
	int T;
	bool find = false;

	for (int i = 1; i < 256; i++){
		if (!find){
			if (accumulate < threshold){
				accumulate += histogram[i];
			}
			else {
				find = true;
				T = i - 1;
				accumulate -= histogram[i - 1];
			}
		}
		if (max_num < histogram[i]){
			max_num = histogram[i];
			max = i;
		}
	}
	//cout << threshold << endl << T << endl << accumulate << endl << endl;

	// normalize the histogram between 0 and histImage.rows
	for (int i = 0; i < 255; i++){
		histogram[i] = ((double)histogram[i] / max_num)*histImage.rows;
	}

	// draw the intensity line for histogram
	for (int i = 0; i < 255; i++)
		line(histImage, Point(bin_w*(i), hist_h), Point(bin_w*(i), hist_h - histogram[i]), Scalar(0, 0, 0), 1, 8, 0);

	// display histogram
	if(binaryShow)
		imshow("Intensity Histogram", histImage);
	cvWaitKey();
	return T;
}
void Binarization(){
	cout << "Image binarizing..." << endl;
	int T = HistogramCalulation(R1);
	cout << "Threshold for binarization: " << T << endl << endl;
	threshold(R2, b2_binary, T, 255, CV_THRESH_BINARY);
	if (binaryShow)
		imshow("Binarization", b2_binary);
	imwrite("b2_binary.jpg", b2_binary);
	cvWaitKey();
}
void Refinement(){
	cout << "Image Refining..." << endl << endl;
	/// Create window
	if (refineShow){
		namedWindow("Refine Image", CV_WINDOW_AUTOSIZE);
		createTrackbar("Morph size:", "Refine Image", &morph_size, max_morph_size, RefineThreshold);
	}
	RefineThreshold(0, 0);
}
void RefineThreshold(int, void*){
	Mat element = getStructuringElement(morph_elem, Size(2 * morph_size + 1, 2 * morph_size + 1), Point(morph_size, morph_size));
	b3_refine = b2_binary.clone();
	/// Apply the specified morphology operation
	morphologyEx(b3_refine, b3_refine, close_operator, element);
	imwrite("b3_refine_c1.jpg", b3_refine);
	morphologyEx(b3_refine, b3_refine, open_operator, element);
	imwrite("b3_refine_c1o1.jpg", b3_refine);
	morphologyEx(b3_refine, b3_refine, open_operator, element);
	imwrite("b3_refine_c1o2.jpg", b3_refine);
	if (refineShow)
		imshow("Refine Image", b3_refine);
	cvWaitKey();
	
}
void Separation(){
	cout << "Image Separating..." << endl << endl;
	Mat temp = b3_refine + a4_edges;
	portrait = b3_refine & a4_edges;
	Mat a4_invert;
	bitwise_not(temp, temp);
	bitwise_not(b3_refine, b3_invert);
	bitwise_not(a4_edges, a4_invert);
	temp = b3_invert - temp;
	bitwise_not(temp, b4_area);
	imwrite("b4_area.jpg", b4_area);
	imwrite("portrait.jpg", portrait);
	if (separateShow){
		imshow("Skeching contour", a4_edges);
		imshow("Filling area", b4_area);
		imshow("Final portriat", portrait);
		cvWaitKey();
	}
}
void DrawSimulation(){
	//SketchSimulation();
	FillSimulation();
}
void SketchSimulation(){
	sort(contours_filtered.begin(),contours_filtered.end(),CompareLength);
	
	simulation = Mat::ones(detect_edges.size(), CV_8UC1);
	simulation.setTo(Scalar(255, 255, 255));
	for (int i = 0; i < contours_filtered.size(); i++) {
		//cout << contours_filtered[i].size() << endl;
		cout<<"Length of "<<i+1<<" contour: "<<arcLength(contours_filtered[i], false)<<endl;
		for (int j = 0; j < contours_filtered[i].size()*1/2; j++){
			//cout << contours_filtered[i][j] << endl;
			line(simulation, contours_filtered[i][j], contours_filtered[i][j + 1], Scalar(0,0,0), 2);
			//circle(simulation, contours_filtered[i][j], 1, (0, 0, 0));
			imshow("Drawing Simulation", simulation);
			cvWaitKey(10);
		}
	}	
	cvWaitKey(0);
}
void FillSimulation(){
	
	//BoundingBox(contours, hierarchy);
	ConnectedComponent();
	
	//imshow(" ", label_image);
	//imwrite("label_image.jpg", label_image);

	//cvWaitKey(0);

	// Randomly color the blobs
	/*
	for (size_t i = 0; i < blobs.size(); i++) {
	int num = int(blobs[i].size()*0.01);
	if (num == 0) num = 3;
	cout << "Number of points in region " << i+1 << " : "<<blobs[i].size()<< " Number to draw " << i + 1 << " : " << num << endl;
	for (size_t j = 0; j < num; j++) {
	int point = rng.uniform(1, int(blobs[i].size()));
	int x = blobs[i][point].x;
	int y = blobs[i][point].y;
	circle(simulation, Point(x, y), 0, Scalar(0, 0, 0), 3);
	imshow("Drawing Simulation", simulation);
	cvWaitKey(10);
	}
	}
	cvWaitKey(0);
	*/

	// Randomy color the blobs
	
	bool find = false;
	int global_y = -1;
	//Mat fill = Mat::zeros(b3_invert.size(), CV_8UC3);
	//fill.setTo(Scalar(255, 255, 255));

	vector <Mat> fill_regions;

	for (size_t i = 0; i < blobs.size(); i++) {
		unsigned char r = 255 * (rand() / (1.0 + RAND_MAX));
		unsigned char g = 255 * (rand() / (1.0 + RAND_MAX));
		unsigned char b = 255 * (rand() / (1.0 + RAND_MAX));
		Mat fill = Mat::zeros(b3_invert.size(), CV_8UC1);
				
		//cout << "Number of points in region " << i + 1 << " : " << blobs[i].size() << endl;
		int label = label_image.at<int>(blobs[i][0].y, blobs[i][0].x);
		
		for (size_t j = 0; j < blobs[i].size(); j++) {
			
			int x = blobs[i][j].x;
			int y = blobs[i][j].y;
			fill.at<char>(y, x) = 255;
			/*
			if (i == 0 && j<250)cout << x << " " << y << endl;

			if (y == global_y)
				find = true;
			else
				find = false;

			// find the first point of each rows
			if (!find){
				vector<Point> points;
				circle(fill, Point(x, y), 1, Scalar(255, 0, 0), 1);
				points.push_back(Point(x, y));

				int x2 = x + 1;
				int y2 = y - 1;
				bool cross = false;

				//find crossing points 
				while (y2>0 && x2<w){
					if (label_image.at<int>(y2, x2) != label && !cross){
						points.push_back(Point(x2 - 1, y2 + 1));
						cross = true;
					}
					else if (label_image.at<int>(y2, x2) == label && cross){
						points.push_back(Point(x2, y2));
						cross = false;
					}
					x2 = x2 + 1;
					y2 = y2 - 1;
				}

				int num = points.size();
				//cout << "num " << num <<" "<<label<< endl << num / 2 << endl;
				//for (int k = 0; k < points.size(); k++){
				//cout << points[k] << " " << label_image.at<int>(points[k].y, points[k].x) << endl;
				//}

				if (num / 2>0)
				for (int k = 0; k < num / 2; k++){
					//cout << points[2 * k] << " " << points[2 * k+1] << endl;
					line(fill, points[2 * k], points[2 * k + 1], Scalar(r, g, b), 2);
					imshow("fill_region", fill);
					waitKey(100);
				}
				//else if (i == 0){ cout << points[0] << endl; }
			}
			global_y = y;
			*/
		}
		
		fill = HoleFilling(fill);
		fill_regions.push_back(fill);
		boundRects.push_back(BoundingBox(fill));
		Scalar color = Scalar(rng.uniform(0, 255), rng.uniform(0, 255), rng.uniform(0, 255));
		rectangle(fill, boundRects[i].tl(), boundRects[i].br(), color, 2, 8, 0);
		imshow("fill_region", fill);
		cvWaitKey(0);
		//imshow("fill_region", fill);
	}
	

	cout << "Number of ccs: " << blobs.size() << endl;
	cvWaitKey(0);
	
}
bool CompareLength(vector<Point> contour1, vector<Point> contour2) {
	double i = arcLength(contour1, false);
	double j = arcLength(contour2, false);
	return (i > j);
}
bool CompareArea(vector<Point> area1, vector<Point> area2) {
	double i = area1.size();
	double j = area2.size();
	return (i > j);
}
bool CompareBox(Rect area1, Rect area2) {
	double i = area1.area();
	double j = area2.area();
	return (i > j);
}

Rect BoundingBox(Mat holefilled){
	Mat fill_edges;
	vector<Vec4i> hierarchy;
	vector<vector<Point> > contours;
	vector<Rect> boundRect;
	
	/// Detect edges using canny
	Canny(holefilled, fill_edges, low_threshold, low_threshold*ratio, kernel_size);
	findContours(fill_edges, contours, hierarchy, CV_RETR_TREE, CV_CHAIN_APPROX_SIMPLE, Point(0, 0));

	vector<vector<Point> > contours_poly(contours.size());
	for (int i = 0; i < contours.size(); i++)
	{
		approxPolyDP(Mat(contours[i]), contours_poly[i], 3, true);
		boundRect.push_back(boundingRect(Mat(contours_poly[i])));
	}
	
	/// Draw polygonal contour + bonding rects + circles
	Mat drawing = Mat::zeros(fill_edges.size(), CV_8UC3);
	boundRect.erase(unique(boundRect.begin(), boundRect.end()), boundRect.end());
	sort(boundRect.begin(), boundRect.end(), CompareBox);

	// Use two-dimension array to store the distance
	//cout << "Number of box befor filtering: " << boundRect.size() << endl;
	int size = boundRect.size();
	int** point_dis = new int*[size];
	for (int i = 0; i < size; ++i)
		point_dis[i] = new int[size];
	for (int i = 0; i < size; i++)
		for (int j = 0; j < size; j++)
			point_dis[i][j] = norm(boundRect[i].br() - boundRect[j].br()) + norm(boundRect[i].tl() - boundRect[j].tl());
	
	vector <int> deleteBoxIndex;
	for (int i = 0; i < size; i++)
		for (int j = i+1; j < size; j++)
			if (point_dis[i][j] < 5)
				deleteBoxIndex.push_back(i);
			
			for (int i = deleteBoxIndex.size() - 1; i >= 0; i--)
		boundRect.erase(boundRect.begin() + deleteBoxIndex[i]);
	
	for (int i = 0; i< boundRect.size(); i++)
	{
		Scalar color = Scalar(rng.uniform(0, 255), rng.uniform(0, 255), rng.uniform(0, 255));
		//drawContours(drawing, contours_poly, i, color, 1, 8, vector<Vec4i>(), 0, Point());
		//cout << boundRect[i].tl() << " " << boundRect[i].br() << " " << boundRect[i].area() << endl;
		rectangle(drawing, boundRect[i].tl(), boundRect[i].br(), color, 2, 8, 0);
	}
	//cout << "Number of box after filtering: " << boundRect.size() << endl<<endl;

	/// Show in a window
	//imshow("Contours", drawing);
	//cvWaitKey(0);
	return boundRect[0];
}
Mat HoleFilling(Mat fill_region)
{
	//cvtColor(fill_region, fill_region, CV_BGR2GRAY);
	Mat image_thresh;
	threshold(fill_region, image_thresh, 125, 255, THRESH_BINARY);

	// Loop through the border pixels and if they're black, floodFill from there
	Mat mask;
	image_thresh.copyTo(mask);
	for (int i = 0; i < mask.cols; i++) {
		if (mask.at<char>(0, i) == 0)
			floodFill(mask, Point(i, 0), 255, 0, 10, 10);
		if (mask.at<char>(mask.rows - 1, i) == 0)
			floodFill(mask, Point(i, mask.rows - 1), 255, 0, 10, 10);
	}
	for (int i = 0; i < mask.rows; i++) {
		if (mask.at<char>(i, 0) == 0)
			floodFill(mask, Point(0, i), 255, 0, 10, 10);
		if (mask.at<char>(i, mask.cols - 1) == 0)
			floodFill(mask, Point(mask.cols - 1, i), 255, 0, 10, 10);
	}
		Mat holefilled;
	// Compare mask with original.
	image_thresh.copyTo(holefilled);
	for (int row = 0; row < mask.rows; ++row) {
		for (int col = 0; col < mask.cols; ++col) {
			if (mask.at<char>(row, col) == 0) {
				holefilled.at<char>(row, col) = 255;
			}
		}
	}
	bitwise_not(holefilled, holefilled);
	//imshow("Final image", holefilled);
	return holefilled;
	//imwrite("final.jpg", newImage);
	//waitKey(0);
}
void ConnectedComponent(){
	Mat binary;
	threshold(b3_invert, binary, 0.0, 1.0, THRESH_BINARY);
	FindBlobs(binary, blobs, label_image);
	sort(blobs.begin(), blobs.end(), CompareLength);
}
void FindBlobs(const Mat &binary, vector < vector<Point2i> > &blobs, Mat &label_image)
{
	blobs.clear();

	// Fill the label_image with the blobs
	// 0  - background
	// 1  - unlabelled foreground
	// 2+ - labelled foreground

	binary.convertTo(label_image, CV_32SC1);

	int label_count = 2; // starts at 2 because 0,1 are used already

	for (int y = 0; y < label_image.rows; y++) {
		int *row = (int*)label_image.ptr(y);
		for (int x = 0; x < label_image.cols; x++) {
			if (row[x] != 1) {
				continue;
			}

			Rect rect;
			floodFill(label_image, Point(x, y), label_count, &rect, 0, 0, 4);

			vector <Point2i> blob;

			for (int i = rect.y; i < (rect.y + rect.height); i++) {
				int *row2 = (int*)label_image.ptr(i);
				for (int j = rect.x; j < (rect.x + rect.width); j++) {
					if (row2[j] != label_count) {
						continue;
					}
					blob.push_back(Point2i(j, i));
				}
			}
			
			blobs.push_back(blob);

			label_count++;
		}
	}
}